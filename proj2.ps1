#Requires -RunAsAdministrator
# +------------------+
# │  CONFIGURATION   │
# |    AND SETUP     |
# +------------------+

$DEBUG_CLEAN = $true      # Deletes the exports file
$forceExecution = $true

# HASHING ALGORITHM USED
$HASH_ALGORITHM = "MD5"

# USER AND TEMP FILE SEARCHING
# Not exactly recommended in most cases.
$ExportUserExecutables = $false
$ExportTmpExecutables = $true   # It is more likely a executable in a tmp folder is malicious than it isn't.

# What extensions are exportable, and what ones are suspicious when found in tmp
$ExportableExtensions = ".exe", ".py", ".dll", ".ps1", ".bat", ".msi", ".vbs"
$SuspiciousTMP = ".zip", ".rar", ".7z", ".txt", ".docx", ".xlsx"
$SuspiciousTMP += $ExportableExtensions # Executables in tmp are suspicious

# Enable hasing all files in the all users' Documents, Downloads, and Desktop direcories
# Useful in some cases, such as when malware is being spread VIA office files
$hashUserFiles = $False

# SSH Related info
# This exports all the authorized_keys files
$GetSSHData = $true
# Maximum allowed number of SSH keys in an ssh file.
# For example, set this to 0 if this computer shouldn't have SSH access,
# It would be set to 1 if a machine should only be accessable by one key
$SSH_MAX_AUTH_KEYS = 0

# Event log information
$eventLogTargets="Security", "System" # Normally I would include powershell logging, but I do not have access to a computer that can log powershell
$maxLogEntries = 500 #Amount of entries to export

$dumpRegistryAutoruns = $true
$RegistryAutorunsLocations = "HKCU:Software\Microsoft\Windows\CurrentVersion\Run", "HKCU:Software\Microsoft\Windows\CurrentVersion\RunOnce", "HKLM:Software\Microsoft\Windows\CurrentVersion\Run", "HKLM:Software\Microsoft\Windows\CurrentVersion\RunOnce"
$RegistryAutoServicesLocations = "HKCU:Software\Microsoft\Windows\CurrentVersion\RunServices", "HKCU:Software\Microsoft\Windows\CurrentVersion\RunServicesOnce", "HKLM:Software\Microsoft\Windows\CurrentVersion\RunServices", "HKLM:Software\Microsoft\Windows\CurrentVersion\RunServicesOnce"


#BASE DIRECTORY
# By default the files are stored ajacent to the executable
$basedir = ".\"
$outputDestination = "Exports\" # This is the folder name to export to
$outPath = $basedir + $outputDestination
$auditPath = "$outPath\audit.log"


#DEBUG: Delete all files generated by the script and make new ones each time
if ($DEBUG_CLEAN) {
  Write-Output "Deleting all generated files"
  Remove-Item $outPath
}


# Create .\Exports if necessary
if (-Not(Test-Path $outPath -PathType Container)) {
  New-Item -Path $outPath -ItemType Directory | Out-Null

  Write-Output "Writing data to $outPath and writing audit to $auditPath"
  Write-Output "Created folder: $outPath`nFolder will be used for exporting data!" |
    Out-File "$auditPath"

  # This is here because otherwise the check below would stop the program
  $forceExecution = $true
}

# Test organizational folders for existance. Create them if necessary
if (-Not (Test-Path "$outPath\Prefetch" -PathType Container)) {
  New-Item -Path "$outPath\Prefetch" -ItemType Directory | Out-Null
}

if ($ExportUserExecutables -or $ExportTmpExecutables) {
  New-Item -Path "$outPath\Executables" -ItemType Directory | Out-Null
}

if ($GetSSHData) {
  New-Item -Path "$outPath\SSH" -ItemType Directory | Out-Null
}

# Checking if audit.log exists. Exit if it does
# Force execution prevents this check.
if ((Test-Path $auditPath -PathType Leaf) -And (-Not $forceExecution)) {
  Write-Output "File $auditPath already exists!"
  Write-Output "Exiting! Will not continue!"
  Exit
}

# +------------------+
# │  GENERAL  INFO   │
# +------------------+
Write-Output "Beginning at`t $([datetime]::Now.ToUniversalTime())`n" |
  Out-File -Append "$auditPath"

# General information
# This is also being written to the audit.log
Write-Output "------------ General information ------------`n" |
  Out-File -Append "$auditPath"

Write-Output "Hostname:`t$((Get-CimInstance -ClassName Win32_ComputerSystem).Name)" | 
  Out-File -Append "$auditPath"

Write-Output "Username:`t$ENV:USERNAME`n" | 
  Out-File -Append "$auditPath"

$AVStatus = Get-MpComputerStatus # This variable will be referenced again later

# +------------------+
# │   VERSION INFO   │
# +------------------+
Write-Output "Retrieving version information for OS, Powershell, and Windows Defender"

Write-Output "OS Version:`t`t`t`t$([System.Environment]::OSVersion.VersionString)" | 
  Out-File -Append "$auditPath"

Write-Output "Powershell Version:`t`t$($PSVersionTable.BuildVersion)`n" | 
  Out-File -Append "$auditPath"

Write-Output "Windows Defender Version:`t`t$($AVStatus.AMProductVersion)" |
  Out-File -Append "$auditPath"

Write-Output "Windows Defender Signatures:`t$($AVStatus.AntivirusSignatureVersion)" |
  Out-File -Append "$auditPath"

Write-Output "Windows Defender Sig. Date:`t`t$($AVStatus.AntivirusSignatureLastUpdated)`n`n" |
  Out-File -Append "$auditPath"


# +------------------+
# │   LOCAL  USERS   │
# +------------------+
$LocalUsers = Get-LocalUser

Write-Output "Getting local users"

Write-Output "Enabled users:" |
  Out-File -Append "$auditPath"

$LocalUsers | ForEach-Object {
  if ($_.Enabled) {
    Write-Output "Name:`t`t`t $($_.Name)" 
    Write-Output "Description:`t $($_.Description)`n"
  }
} | Out-File -Append "$auditPath"

# Getting disabled users
Write-Output "`nDisabled users:"  |
  Out-File -Append "$auditPath"

$LocalUsers | ForEach-Object {
  if (-not $_.Enabled) {
    Write-Output "Name:`t`t`t $($_.Name)" 
    Write-Output "Description:`t $($_.Description)`n" 
  }
} | Out-File -Append "$auditPath"


# +------------------+
# │ INTERFACE ADDRS. │
# +------------------+
Get-NetIPAddress -AddressFamily IPv4 | 
ForEach-Object {
  Write-Output "$($_.InterfaceAlias):
IPv4:`t`t`t$($_.IPAddress)
DHCP Lifetime:`t$($_.ValidLifetime)`n"
} | Out-File -Append "$auditPath"


# +------------------+
# │   DNS  RECORDS   │
# +------------------+
Write-Output "Dumping DNS Records`n"
Write-Output "Dumping DNS records to $outPath\dns.csv" |
  Tee-Object -Append -FilePath $auditPath

Get-DnsClientCache | Select Entry, RecordName, RecordType, Status, TimeToLive, Data | 
  Export-Csv -NoTypeInformation $outPath\dns.csv -Append

# +------------------+
# │ TCP  CONNECTIONS │
# +------------------+
Write-Output "Dumping network connectiosn to netconnections.csv" |
  Tee-Object -Append $auditPath

Get-NetTCPConnection |
  Export-Csv $outPath\netconnections.csv


# Checking AV Status
Write-Output "------------ Windows Devender AV ------------`n" |
  Out-File -Append "$auditPath"

Write-Output "`nAMService Enabled:`t`t`t$($AVStatus.AMServiceEnabled)" |
  Tee-Object -Append -FilePath $auditPath
Write-Output "AntiSpyware Enabled:`t`t`t$($AVStatus.AntiSpywareEnabled)" |
  Tee-Object -Append -FilePath $auditPath
Write-Output "AntivirusEnabled:`t`t`t$($AVStatus.AntivirusEnabled)" |
  Tee-Object -Append -FilePath $auditPath
Write-Output "BehavioralEnabled:`t`t`t$($AVStatus.BehaviorMonitorEnabled)`n" |
  Tee-Object -Append -FilePath $auditPath

Write-Output "Windows Defender Exclusions:`nNote that no output means there is no exclusions`n" |
  Out-File -Append "$auditPath"


$AVPreferences = Get-MpPreference # This variable is referenced to determine exclusions

Write-Output "Extensions:`t`t$($AVPreferences.ExclusionExtension)`n" |
  Tee-Object -Append -FilePath $auditPath

Write-Output "IP Addresses:`t$($AVPreferences.ExclusionIpAddress)`n" |
  Tee-Object -Append -FilePath $auditPath

Write-Output "Paths:`t`t`t$($AVPreferences.ExclusionIpAddress)`n" | 
  Tee-Object -Append -FilePath $auditPath

Write-Output "Processes:`t`t$($AVPreferences.ExclusionProcess)`n" |
  Tee-Object -Append -FilePath $auditPath

# +------------------+
# │   PROCESS DATA   │
# +------------------+

#Logging in audit.log
Write-Output "Gathering Process information to processes.txt and processes.csv`n" |
  Tee-Object -Append -FilePath $auditPath

# Snapshot of running processes
Get-Process | Out-File "$outPath\processes.txt"

# Adding separation
Write-Output "`n" |
  Out-File -Append "$outPath\processes.txt"

# Startup processes
Write-Output "----------------------STARTUP PROCESSES---------------------`n" |
  Out-File -Append $outPath\processes.txt

Get-Process |
  Export-Csv -Append "$outPath\processes.csv"
  
# There is some bad format in code for this command, but it is just a string that is formatted to show the name, location, and usr of a startup command
Get-CimInstance Win32_StartupCommand | 
  ForEach-Object {
    Write-Output "$($_.Name):
cmd:`t`t$($_.Command)
loc:`t`t$($_.Location)
usr:`t`t$($_.User)`n"
} | Out-File -Append "$outPath\processes.txt" 




# +------------------+
# │     SERVICES     │
# +------------------+
Write-Output "Dumping process information to services.csv`n" |
  Tee-Object -Append $auditPath
  
Get-Service |
  Export-Csv $outPath\services.csv


# +------------------+
# │   DUMPING LOGS   │
# +------------------+
foreach ($lname in $eventLogTargets) {
  Write-Output "Dumping event logs for $lname" |
    Tee-Object -Append $auditPath
    
  Get-EventLog -LogName $lname -newest $maxLogEntries |
    Export-csv "$outPath\logs-$lname.csv"
}

# +------------------+
# │  FILE  SCANNING  │
# |   (User files)   |
# +------------------+

# Enumerate through the users' Desktop, Documents, and Downloads folder
# Hash all files, and add them to a table (CSV and optionally JSON too)
# Optionally, export
if ($hashUserFiles) { 
  Write-Output "Hashing user files...`nThis might take a while..."
  Write-Output "Hashing files in all user's Downloads, Documents, and Desktop directories" | 
    Out-File -Append $auditPath
}
else {
  Write-Output "Recording data about user files. Hashing is disabled."
}

Write-Output "File Name, Creation Time (UTC), Last Write (UTC), Hash (optional), Hash type" |
  Out-File $outPath\userFiles.csv

# Using nested for each loops because I am trying to only recurse into certain directories (downloads, documents, desktop)
Get-ChildItem "C:\Users" | ForEach-Object {
  Get-ChildItem $_.FullName | ForEach-Object {
    if (($_.Name -eq "Downloads") -or ($_.Name -eq "Documents") -or ($_.name -eq "Desktop")) {
      Get-ChildItem $_.FullName -Recurse | ForEach-Object {
        # We can't hash folders, so we must make sure they are not one
        if (-not ((Get-Item $_.FullName) -is [System.IO.DirectoryInfo])) {
          # Write file path, creation time, last modify, and if enabled, hashes and hash type
          Write-Output "$($_.FullName),$($_.CreationTimeUtc),$($_.LastWriteTimeUtc),$(if($hashUserFiles){Get-FileHash -Path "$($_.FullName)" -Algorithm $HASH_ALGORITHM -ErrorAction SilentlyContinue}),$HASH_ALGORITHM" |
            Out-File -Append $outPath\userFiles.csv
        }

        # Export executables and scripts if found in these files
        # Only do so if enabled ($ExportUserExecutables = $true)
        # -export is added to the name to make it harder to accidentally run a potentially
        # malicious file that is grabbed by this script
        if ($ExportUserExecutables) {
          if ($ExportableExtensions.Contains($_.Extension)) {
            Copy-Item -Path $_.FullName -Destination "$outPath\executables\$($_.name)-export"
          }
        }
      } 
    } 
  }
}


# +------------------+
# │  FILE  SCANNING  │
# |   (Temp files)   |
# +------------------+
# Determining all temp locations
[array]$searchable = Get-ChildItem "C:\Users" | 
ForEach-Object {
  # Because Public doesn't have an appdata or tmp, it is ignored
  if (-not ($_.name -eq "Public")) {
    "$($_.FullName)\AppData\Local\Temp"
  }
}
$searchable += "C:\Windows\Temp"

Write-Output "Examining temporary folders:" |
  Tee-Object -Append $auditPath
if ($ExportTmpExecutables) {
  Write-Output "Executables found in temporary folders will be copied to Exports\Executables"
}

Get-ChildItem -Recurse $searchable | ForEach-Object {

  # Check if a file in a temp directory has a suspicious extension
  if ($SuspiciousTMP.Contains($_.Extension)) {
    Write-Output "Possible suspicious temp file found: $($_.fullName)" |
     Tee-Object -Append -FilePath $auditPath
        
    # Hash the suspicious file
    Get-FileHash -Path "$($_.FullName)" -Algorithm $HASH_ALGORITHM |
      Export-Csv -Append $outPath\hashes.csv
  }

  # If enabled, export executables from temp
  if ($ExportTmpExecutables) {
    if ($ExportableExtensions.Contains($_.Extension)) {
      Copy-Item -Path $_.FullName -Destination "$outPath\Executables\$($_.name)-export"
    }
  }
}



# +------------------+
# │ COPYING PREFETCH │
# |      FILES       |
# +------------------+

Write-Output "`nCopying Prefetch files:" |
  Tee-Object -Append $auditPath

Write-Output "File Name, Last Write, Hash, Algorithm" |
  Out-File $outPath\prefetch.csv

Get-ChildItem "C:\Windows\Prefetch" |
Sort-Object LastWriteTime -Descending |
  ForEach-Object {
    if ($_.Extension -eq ".pf") {
      Copy-Item -Path $_.fullName -Destination "$outPath\Prefetch"

      # Hashing and logging
      Write-Output "$($_.Name),$($_.LastWriteTime),$((Get-FileHash $_.fullName -Algorithm $HASH_ALGORITHM).hash),$HASH_ALGORITHM" |
        Out-File -Append $outPath\prefetch.csv
  }
}



# BELOW HERE ARE POTENTIALLY EXTRANEOUS OPERATIONS
# THEY ARE ORDERED BY USEFULNESS
# SOME OF THEM ARE INCLUDED BECAUSE THEY MAY BE USEFUL IN A COMPETITION SETTING!

# +------------------+
# │  GET .SSH INFO   │
# |    (Optional)    |
# +------------------+
if ($GetSSHData) {
  # Test for each user
  Write-Output "`nRetrieving SSH Data" | 
    Tee-Object -Append -FilePath "$auditPath"

  Write-Output "Maximum Accepted keys: $SSH_MAX_AUTH_KEYS" | 
    Tee-Object -Append -FilePath "$auditPath"
  # Enumerate through the users folder and search through their ssh files
  Get-ChildItem "C:\Users" |
    ForEach-Object {
      # Test if the .ssh directory exists.
      if (Test-Path "$($_.FullName)\.ssh" -PathType Container) {

      # Check if there is an authorized keys file
        if (Test-Path "$($_.FullName)\.ssh\authorized_keys") {
          Write-Output "authorized_keys file found for $($_.Name)! File is being copied to Exports!" |
            Tee-Object -Append -FilePath $auditPath
                    
          Copy-Item -Path "$($_.FullName)\.ssh\authorized_keys" -Destination "$outPath\SSH\authorized_keys-$($_.Name)"

          # Getting an accurate count of entries in the authorized_keys file
          # There is supposed to be one entry per line (and each entry is one line)
          # However, whitespace is ignored, and I don't want to count it!
          #https://community.idera.com/database-tools/powershell/powertips/b/tips/posts/ignoring-empty-lines
          $lc = (Get-Content -Path "$($_.FullName)\.ssh\authorized_keys" | 
            Where-Object { $_.Trim() -ne '' } |
            Measure-Object -Line).Lines
                    
          # If we have too many keys in the authorized_keys, it should be examined
          if ($lc -gt $SSH_MAX_AUTH_KEYS) {
            Write-Output "There are more entries in $($_.FullName)\authorized_keys than allowed!" |
              Tee-Object -Append -FilePath $auditPath
          }
        }
        elseif (Test-Path "$($_.FullName)\.ssh\known_hosts") {
          Write-Output "known_hosts file found for $($_.Name)! File is being copied to Exports!" |
            Tee-Object -Append -FilePath $auditPath

          Copy-Item -Path "$($_.FullName)\.ssh\known_hosts" -Destination "$outPath\SSH\known_hosts-$($_.Name)"
        }
        elseif (Test-Path "$($_.FullName)\.ssh\config") {
          Write-Output "ssh config file found for $($_.Name)! File is being copied to Exports!" |
            Tee-Object -Append -FilePath $auditPath

          Copy-Item -Path "$($_.FullName)\.ssh\config" -Destination "$outPath\SSH\ssh_config-$($_.Name)"
        }
      $count++
    }
  } #End ForEach
  if ($count -eq 0) {
    Write-Output "No SSH files found!" |
    Tee-Object -Append -FilePath $auditPath
  }
}


# +------------------+
# │ DUMPING REGISTRY │
# |    (Optional)    |
# +------------------+
# I am not a registry wizard, so I plan on dumping only what I see in autoruns

if ($dumpRegistryAutoruns) {
  # $PSStyle.OutputRendering = [System.Management.Automation.OutputRendering]::PlainText; # This should have fixed the colors error :(

  Write-Output "`nChecking registry for autoruns" | 
    Tee-Object -Append -FilePath $auditPath

  $RegistryAutorunsLocations | Get-Item |
    Tee-Object -append $outPath\registry-autoruns.txt
    
    # These keys don't always exist
  $RegistryAutoServicesLocations | ForEach-Object{
    if(Test-Path $_){
      $_ | Get-Item | 
        Write-Output $outPath\registry-autoservices.txt
    }
  }
}


# +------------------+
# │ COMPRESSING FILE │
# +------------------+
Write-Output "`n`nDONE $([datetime]::Now.ToUniversalTime()) `nCompressing Exports file." | 
  Tee-Object -Append $auditPath
Compress-Archive -Path $outPath -Destination "$basedir\Exports.zip"  -CompressionLevel Fastest -Force | Out-Null